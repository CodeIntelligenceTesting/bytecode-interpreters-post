#+OPTIONS: ^:nil num:nil p:nil timestamp:nil todo:nil date:nil creator:nil author:nil toc:nil
#+TITLE: Полет свиньи (или оптимизация интерпретаторов байт-кода)
* DONE развитая стековая машина

  - [X] чтение байт-кода из файла

  - [X] специальный нулевой байт-код

  - [X] ассемлер, дизассемблер

  - [X] система тестов

  - [X] 16 bit args in the machine

  - [X] 16 bit args in assembler/disassembler

  - [X] печать значений со стека

  - [X] JUMP

  - [X] EQUAL/LESS/LESS_OR_EQUAL/GREATER/GREATER_OR_EQUAL/

  - [X] asm/disasm update

  - [X] JUMP_IF_TRUE/JUMP_IF_FALSE

  - [X] метки в ассемблере (создание и использование в JUMP-ах)

  - [X] DUP

  - [X] массив памяти, загрузка на стек и обратно

  - [X] поддержка памяти в асм

  - [X] обновить Makefile

* DONE решето Эратосфена в ассемблере для ПятачокВМ

  sieve.pvm

* DONE простые оптимизации

  - [X] замерить скорость без оптимизаций

    default optimisation:

    x100 - 1.5 с

    -O3:

    x100 - 0.6 с

  - [X] сравнить с питоном

    x100 - 4.5 с

  - [X] оставить тэг для неоптимизированного кода

  - [X] отпрофилировать все толком

    17/13% на функции работы со стеком, по умолчанию не инлайнились

  - [X] макросы для работы со стеком

    1.5 -> 1.25s

    теперь почти весь код работает через switch, который и занимает порядка 30% времени

  - [X] работа со стеком без замены значения

    1.25 -> 1.15s

  - [X] специальные байт-коды и нединамические суперинструкции

    PUSHI/LOADI

    1.15 -> 0.95s

    -O3:

    x100 - 0.45s

  - [X] range check

    -O3:  x100 - 0.41s

* DONE шитый код

  - [X] token threaded code

    0.95 -> 0.8

    -O3: 0.5s

* DONE кэш трасс

  - [X] non-jumping trace

  non-optimized: 1.2s

  -O3: 0.38s

  avg trace size: 4.42 (+1,2)

  - [X] jumping trace

  avg trace size: 5.1

  non-optimized:

  -O3: 0.36
* DONE libjit

  - [X] compile libjit

  - [X] come up with a simple example function

  - [X] pigletvm libjit plan

  - [X] imitate an instruction pointer increment/decrement

  - [X] imitate a stack push/pop/peek

  - [X] imitate a setjump/longjump

    should be done as a part of the standard exception handling logic

  - [X] plan the integration of jit

  - [X] get the scaffolding in place

  - [X] run with DONE/ABORT only

  - [X] add the tail handling compiler

  - [X] add separate stack handling routines

  - [X] extract common stack op compiling into separate compiling helpers

  - [X] add everything but the branching instructions

  - [X] measure the code

    10 times slower, failer
* DONE зачистить репоз от мусора, оставшегося от первых версий
* DONE подготовить код к презентации идей
* DONE список вещей, которые надо упомянуть

  - акцент статьи на низкоуровневых нинтерпретаторах байт-кода и причины такого интереса

  - макросы для работы со стеком

  - статические суперинструкции

  - теоретическая возможность использования динамические суперинструкций

  - борьба с проверкой в свитче

  - простой "шитый код"

  - трейсы

  - оптимизация работы со стеком - фиксированная глубина стека на каждой инструкции

  - что-то еще было?

* TODO ссылки в статье
* TODO обновить комментарии на Гитхабе
* TODO [0/10] Статья
** TODO Аннотация

   #+BEGIN_QUOTE
   "No matter how hard you try, you can't make a racehorse out of a pig. You can, however, make a
   faster pig."

   Джеми Завинский (комментарий к исходному коду Емакса)
   #+END_QUOTE

   Широко известен тот факт, что свиньи летают не могут. Не менее популярно мнение о том, что
   интерпретаторы байт-кодов, популярнейшая техника исполнения языков высокого уровня, не поддаются
   ускорению без применения трудоемкой динамической компиляции.

   Во второй части серии статей об интерпретаторах байт-кода я на примере небольшой стековой
   виртуальной машины ПоросенокВМ все же постараюсь показать, что не все потеряно для трудолюбивых
   поросят с амбициями и что в рамках (в основном) стандартного Си вполне возможно ускорить работу
   такого интерпретатора по меньшей мере в полтора раза.

** TODO Описание машины и рассуждение о возможных направлениях оптимизации

   Итак, давайте знакомиться.

   ПоросенокВМ - заурядная стековая машина, основанная на примере стековой машины из первой части
   статьи. Наша свинка знает только один тип данных - 64-битное машинное слово, а все
   (целочисленные) вычисления производит на стеке максимальной глубиной в 256 машинных слов. Кроме
   стека у Поросенка имеется рабочая память длиной в 65536 машинных слов. Результат выполнения
   программы - одно машинное слово - можно либо поместить в специальный регистр результата, либо
   просто вывести в стандартный вывод (stdout).

   Все состояние в ПоросенокВМ хранится единственной статической структурой:

   #+BEGIN_SRC cpp
static struct {
    /* Current instruction pointer */
    uint8_t *ip;

    /* Fixed-size stack */
    uint64_t stack[STACK_MAX];
    uint64_t *stack_top;

    /* Operational memory */
    uint64_t memory[MEMORY_SIZE];

    /* A single register containing the result */
    uint64_t result;
} vm;

   #+END_SRC

   Все вышеперечисленное относит ПоросенокВМ к низкоуровневым виртуальным машинах, главные накладные
   расходы в которых приходятся на обслуживание основного цикла работы программы:

   #+BEGIN_SRC cpp
interpret_result vm_interpret(uint8_t *bytecode)
{
    vm_reset(bytecode);

    for (;;) {
        uint8_t instruction = NEXT_OP();
        switch (instruction) {
        case OP_PUSHI: {
            /* get the argument, push it onto stack */
            uint16_t arg = NEXT_ARG();
            PUSH(arg);
            break;
        }
        case OP_ADD: {
            /* Pop 2 values, add 'em, push the result back to the stack */
            uint64_t arg_right = POP();
            *TOS_PTR() += arg_right;
            break;
        }

        /*
        * ...
        * Lots of other instruction handlers here
        * ...
        */

        case OP_DONE: {
            return SUCCESS;
        }
        default:
            return ERROR_UNKNOWN_OPCODE;
        }
    }

    return ERROR_END_OF_STREAM;
}

    #+END_SRC

   Из кода видно, что на каждый опкод Поросенок должен:

   1. Извлечь опкод из потока инструкций.

   2. Убедиться, что опкод входит в допустимый интервал значений опкодов - эту логику добавляет
      компилятор Си при генерации кода switch-а.

   3. Перейти к телу одной из инструкций.

   4. Извлечь аргументы инструкции со стека, или декодировать аргумент инструкции, размещенный
      непосредственно в байт-коде.

   5. Выполнить, собственно, операцию.

   6. Если есть результат вычисления - поместить его на стек.

   7. Передвинуть указатель текущей инструкции на следующую и перейти в начало цикла.

   Полезная нагрузка здесь только в 6-ом пункте, остальное же - накладные расходы: декодирование или
   извлечение из стека аргументов инструкции (пункт 5), проверка значения опкода (пункт 3),
   многократные прыжки в начало главного цикла (пункты 7 и 1).

   Словом, у Поросенка явно превышен допустимый индекс массы тела, и если мы хотим привести нашу
   свинью в форму, то придется как-то со всеми этим излишествами бороться.

** TODO Свинский язык ассемблера, решето Эратосфена и первые замеры



** TODO Макросы для работы со стеком
** TODO Суперинструкции, статические или динамические
** TODO Проверка интервала значений
** TODO "Шитый" код
** TODO Предкомпиляция байт-кода, трейсы
** TODO Jit? Другие возможные оптимизации?
** TODO Резюме
