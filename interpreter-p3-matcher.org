#+OPTIONS: ^:nil num:nil p:nil timestamp:nil todo:nil date:nil creator:nil author:nil toc:nil
#+TITLE: Иголка в стоге сессий, или Байт-код регулярных выражений
* DONE Аннотация

  Семнадцать миллиардов событий, шестьдесят миллионов пользовательских сессий и невесть сколько
  виртуальных свиданий происходят в Badoo ежедневно. Каждое из событий аккуратно сохраняется в
  реляционные базы данных для последующего анализа на SQL и не только на нем.

  Современные распределенные транзакционные базы данных с десятками терабайт данных - настоящее чудо
  инженерной мысли. Но SQL как воплощение реляционной алгебры в стандартных реализациях не позволяет
  формулировать сложные запросы в терминах упорядоченных последовательностей кортежей.

  В последней из моих статей, посвященных виртуальным машинам, я расскажу про альтернативный подход:
  движок регулярных выражений ("Поросячий Матчер"), определенных для последовательностей событий -
  пользовательских сессий.

* DONE О событиях и сессиях

  Мы хотим находить сессии по запросами вида: "посчитать все сессии, где имеется указанная
  подпоследовательность событий", или "найти части сессии, описанные заданным шаблоном", или
  "вернуть ту часть сессии, которая случилась после заданного шаблона", или "посчитать, сколько
  сессий достигли определенных частей шаблона". Это может пригодиться для самых разнообразных
  практических анализов: поиск подозрительных сессий, вороночный анализ и т.д.

  Искомые подпоследовательности надо как-то описывать. В самой простой форме эта задача похожа на
  обычный поиск подстроки в тексте; нам же хочется иметь инструмент помощнее - регулярные выражения.
  А современные реализации движков регулярных выражений чаще всего используют - вы угадали! -
  виртуальные машины.

  Созданием небольших виртуальных машинок для сопоставления сессий с регулярными выражениями мы и
  займемся. Но давайте сначала уточним определения.

  Итак, /событие/ состоит из типа события, времени, контекста и набора атрибутов, специфичных для
  каждого из типов.

  /Тип/ и /контекст/ каждого из событий это целые числа из предопределенных списков. Если с типами
  событий все понятно, то контекст это, например, номер экрана, на котором произошло заданное
  событие.

  /Атрибут/ события это произвольное целое число, смысл которого определяется типом события. Атрибутов
  у события может не быть, или быть несколько.

  /Сессия/ это последовательность событий, отсортированных по времени.

  Но давайте, наконец, перейдем к делу. "Гул затих. я вышел на подмостки. "

* DONE Сравниваем по бумажке

  Особенность данной виртуальной машины - пассивность по отношению ко входным данным. Мы не хотим
  держать всю сессию в памяти и позволять виртуальной машине переходить от события к событию. Вместо
  этого мы будем одно за другим подавать события из сессии в виртуальную машинку. Определимся с
  интерфейсными функциями:

  #+BEGIN_SRC cpp

    matcher *matcher_create(uint8_t *bytecode);

    match_result matcher_accept(matcher *m, uint32_t event);

    void matcher_destroy(matcher *matcher);

  #+END_SRC

  Если с функциями matcher_create и matcher_destroy все понятно, то matcher_accept придется
  прокомментировать. Функция matcher_accept получает на вход экземпляр виртуальной машины и
  очередное событие (32 бита, где 16 бит на тип события и 16 бит на контекст), а возращает код,
  поясняющий, что пользовательскому коду делать дальше:

  #+BEGIN_SRC cpp

    typedef enum match_result {
        MATCH_NEXT,                 // подать на вход еще одно событие
        MATCH_OK,                   // успешно найден искомый шаблон, события больше можно не подавать
        MATCH_FAIL,                 // текущая сессия не похожа на искомый шаблон, события можно больше
                                    // не подавать
        MATCH_ERROR,                // внутренняя ошибка в коде
    } match_result;

  #+END_SRC

  Опкоды, из которых состоит байт-код виртуальной машины:

  #+BEGIN_SRC cpp

    typedef enum matcher_opcode {
        OP_ABORT,                   // нулевой опкод, сразу останавливает выполнение с ошибкой
        OP_NAME,                    // проверить тип текущего события тип (аргумент - искомый тип)
        OP_SCREEN,                  // проверить контекст текущего события (аргумент - искомый контекст)
        OP_NEXT,                    // запросить следующее событие
        OP_MATCH,                   // успешно завершить поиск
    } matcher_opcode;

  #+END_SRC

  Главный цикл виртуальной машины:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP()                               \
        (*m->ip++)
    #define NEXT_ARG()                              \
        ((void)(m->ip += 2), (m->ip[-2] << 8) + m->ip[-1])

        for (;;) {
            uint8_t instruction = NEXT_OP();
            switch (instruction) {
            case OP_ABORT:{
                return MATCH_ERROR;
            }
            case OP_NAME:{
                uint16_t name = NEXT_ARG();
                if (event_name(next_event) != name)
                    return MATCH_FAIL;
                break;
            }
            case OP_SCREEN:{
                uint16_t screen = NEXT_ARG();
                if (event_screen(next_event) != screen)
                    return MATCH_FAIL;
                break;
            }
            case OP_NEXT:{
                return MATCH_NEXT;
            }
            case OP_MATCH:{
                return MATCH_OK;
            }
            default:{
                return MATCH_ERROR;
            }
            }
        }

    #undef NEXT_OP
    #undef PEEK_ARG
    }
  #+END_SRC

  В этом простеньком варианте наша виртуальная машина последовательно сопоставляет шаблон из
  байт-кода со входящими событиями. В сущности это не слишком лаконично написанное сопоставление
  /префиксов/ двух строк: искомого шаблона и входной строки.

  Префиксы префиксами, но мы хотим находить искомые шаблоны не только в начале сессии, а в
  произвольном месте. Возможное наивное решение - перезапуск сопоставления с каждого события сессии.
  Но это подразумевает многократный просмотр каждого из событий и поедание алгоритмических
  младенцев.

  Пример из первой части серии статей, в сущности, имитирует перезапуск сопоставления при помощи
  отката (англ. backtracking). Код в примере выглядит, конечно, чище приведенного здесь, но суть
  проблемы не меняется - каждое из событий мы должны посмотреть многократно.

  Так жить решительно нельзя.

* TODO Я, еще раз я и снова я
* TODO Множественные личности и ветвления в шаблонах
* TODO Регулярные выражения на событиях
* TODO Заключение
