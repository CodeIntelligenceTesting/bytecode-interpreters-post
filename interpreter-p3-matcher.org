#+OPTIONS: ^:nil num:nil p:nil timestamp:nil todo:nil date:nil creator:nil author:nil toc:nil
#+TITLE: Иголка в стоге сессий, или Байт-код регулярных выражений
* Аннотация

  Семнадцать миллиардов событий, шестьдесят миллионов пользовательских сессий и невесть сколько
  виртуальных свиданий происходят в Badoo ежедневно. Каждое из событий аккуратно сохраняется в
  реляционные базы данных для последующего анализа на SQL и не только на нем.

  Современные распределенные транзакционные базы данных с десятками терабайт данных - настоящее чудо
  инженерной мысли. Но SQL как воплощение реляционной алгебры в стандартных реализациях не позволяет
  формулировать сложные запросы в терминах упорядоченных последовательностей кортежей.

  В последней из моих статей, посвященных виртуальным машинам, я расскажу про альтернативный подход:
  движок регулярных выражений ("Поросячий Матчер"), определенных для последовательностей событий -
  пользовательских сессий.

* О событиях и сессиях

  Предположим, у нас уже имеется хранилище данных, позволяющее быстро и последовательно
  просматривать события каждой из пользовательских сессий.

  Мы хотим находить сессии по запросами вида: "посчитать все сессии, где имеется указанная
  подпоследовательность событий", или "найти части сессии, описанные заданным шаблоном", или
  "вернуть ту часть сессии, которая случилась после заданного шаблона", или "посчитать, сколько
  сессий достигли определенных частей шаблона". Это может пригодиться для самых разнообразных
  практических анализов: поиск подозрительных сессий, вороночный анализ и т.д.

  Искомые подпоследовательности надо как-то описывать. В самой простой форме эта задача похожа на
  поиск подстроки в тексте; нам же хочется иметь инструмент помощнее - регулярные выражения.
  Современные реализации движков регулярных выражений чаще всего используют - вы угадали! -
  виртуальные машины.

  Созданием небольших виртуальных машинок для сопоставления сессий с регулярными выражениями мы и
  займемся этой статье. Но давайте сначала уточним определения.

  /Событие/ состоит из типа события, времени, контекста и набора атрибутов, специфичных для
  каждого из типов.

  /Тип/ и /контекст/ каждого из событий это целые числа из предопределенных списков. Если с типами
  событий все понятно, то контекст это, например, номер экрана, на котором произошло заданное
  событие.

  /Атрибут/ события это произвольное целое число, смысл которого определяется типом события. Атрибутов
  у события может не быть, или быть несколько.

  /Сессия/ это последовательность событий, отсортированных по времени.

  Но давайте, наконец, перейдем к делу. Гул, как говорится, затих, а я вышел на подмостки.

* Сравниваем по бумажке

  Особенность данной виртуальной машины - пассивность по отношению ко входным данным. Мы не хотим
  держать всю сессию в памяти и позволять виртуальной машине самостоятельно переходить от события к
  событию. Вместо этого мы будем одно за другим подавать события из сессии в виртуальную машинку.

  Определимся с интерфейсными функциями:

  #+BEGIN_SRC cpp

    matcher *matcher_create(uint8_t *bytecode);

    match_result matcher_accept(matcher *m, uint32_t event);

    void matcher_destroy(matcher *matcher);

  #+END_SRC

  Если с функциями matcher_create и matcher_destroy все понятно, то matcher_accept стоит
  прокомментировать. Функция matcher_accept получает на вход экземпляр виртуальной машины и
  очередное событие (32 бита, где 16 бит на тип события и 16 бит на контекст), а возращает код,
  поясняющий, что пользовательскому коду делать дальше:

  #+BEGIN_SRC cpp

    typedef enum match_result {
        MATCH_NEXT,                 // подать на вход еще одно событие
        MATCH_OK,                   // успешно найден искомый шаблон, события больше можно не подавать
        MATCH_FAIL,                 // текущая сессия не похожа на искомый шаблон, события можно больше
                                    // не подавать
        MATCH_ERROR,                // внутренняя ошибка в коде
    } match_result;

  #+END_SRC

  Опкоды, из которых состоит байт-код виртуальной машины:

  #+BEGIN_SRC cpp

    typedef enum matcher_opcode {
        OP_ABORT,                   // нулевой опкод, сразу останавливает выполнение с ошибкой
        OP_NAME,                    // проверить тип текущего события тип (аргумент - искомый тип)
        OP_SCREEN,                  // проверить контекст текущего события (аргумент - искомый контекст)
        OP_NEXT,                    // запросить следующее событие
        OP_MATCH,                   // успешно завершить поиск
    } matcher_opcode;

  #+END_SRC

  Главный цикл виртуальной машины:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP()                               \
        (*m->ip++)
    #define NEXT_ARG()                              \
        ((void)(m->ip += 2), (m->ip[-2] << 8) + m->ip[-1])

        for (;;) {
            uint8_t instruction = NEXT_OP();
            switch (instruction) {
            case OP_ABORT:{
                return MATCH_ERROR;
            }
            case OP_NAME:{
                uint16_t name = NEXT_ARG();
                if (event_name(next_event) != name)
                    return MATCH_FAIL;
                break;
            }
            case OP_SCREEN:{
                uint16_t screen = NEXT_ARG();
                if (event_screen(next_event) != screen)
                    return MATCH_FAIL;
                break;
            }
            case OP_NEXT:{
                return MATCH_NEXT;
            }
            case OP_MATCH:{
                return MATCH_OK;
            }
            default:{
                return MATCH_ERROR;
            }
            }
        }

    #undef NEXT_OP
    #undef PEEK_ARG
    }
  #+END_SRC

  В этом простеньком варианте наша виртуальная машина последовательно сопоставляет шаблон из
  байт-кода со входящими событиями. В сущности это не слишком лаконичное сопоставление /префиксов/
  двух строк: искомого шаблона и входной строки.

  Префиксы префиксами, но мы хотим находить искомые шаблоны не только в начале сессии, а в
  произвольном месте. Возможное наивное решение - перезапуск сопоставления с каждого события сессии.
  Но это подразумевает многократный просмотр каждого из событий и поедание алгоритмических
  младенцев.

  Пример из первой части серии статей, в сущности, имитирует перезапуск сопоставления при помощи
  отката (англ. backtracking). Код в примере выглядит, конечно, лаконичней приведенного здесь, но
  суть проблемы не меняется: каждое из событий мы должны посмотреть многократно.

  Так жить решительно нельзя.

* Я, еще раз я и снова я

  Давайте еще раз проговорим задачу: надо сопоставлять шаблон со входящими событиями, от каждого из
  событий начиная новое сопоставление. Так почему бы нам именно это и не делать? Пускай виртуальная
  машина будет идти по входящим событиям в несколько /потоков/!

  Для этого нам потребуется завести новую сущность - поток. Каждый поток хранит единственный
  указатель на текущую инструкцию:

  #+BEGIN_SRC cpp

    typedef struct matcher_thread {
        uint8_t *ip;
    } matcher_thread;

  #+END_SRC

  Естественно, что и в самой виртуальной машине мы теперь явный указатель хранить не будем. Его
  заменяют два списка потоков (о них чуть ниже):

  #+BEGIN_SRC cpp

    typedef struct matcher {
        uint8_t *bytecode;

        /* Threads to be processed using the current event */
        matcher_thread current_threads[MAX_THREAD_NUM];
        uint8_t current_thread_num;

        /* Threads to be processed using the event to follow */
        matcher_thread next_threads[MAX_THREAD_NUM];
        uint8_t next_thread_num;

    } matcher;

  #+END_SRC

  А вот и обновленный главный цикл:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP(thread)                         \
        (*(thread).ip++)
    #define NEXT_ARG(thread)                                                \
        ((void)((thread).ip += 2), ((thread).ip[-2] << 8) + (thread).ip[-1])

        /* Каждое полученное событие запускает новый поток с начала байт-кода */
        add_current_thread(m, initial_thread(m));

        // На полученное событие мы обрабатываем каждый из потоков
        for (size_t thread_i = 0; thread_i < m->current_thread_num; thread_i++ ) {
            matcher_thread current_thread = m->current_threads[thread_i];

            bool thread_done = false;
            while (!thread_done) {
                uint8_t instruction = NEXT_OP(current_thread);
                switch (instruction) {
                case OP_ABORT:{
                    return MATCH_ERROR;
                }
                case OP_NAME:{
                    uint16_t name = NEXT_ARG(current_thread);
                    // если выясняется, что текущее событие не соответствует шаблону, то текущий поток
                    // не помещается в список next_threads, и завершает выполнение
                    if (event_name(next_event) != name)
                        thread_done = true;
                    break;
                }
                case OP_SCREEN:{
                    uint16_t screen = NEXT_ARG(current_thread);
                    if (event_screen(next_event) != screen)
                        thread_done = true;
                    break;
                }
                case OP_NEXT:{
                    // поток запросил следующее событие, т.е. должен быть помещен в список next_threads
                    add_next_thread(m, current_thread);
                    thread_done = true;
                    break;
                }
                case OP_MATCH:{
                    return MATCH_OK;
                }
                default:{
                    return MATCH_ERROR;
                }
                }
            }
        }

        /* Меняем местами текущий и следующий списки, запрашиваем следующее событие */
        swap_current_and_next(m);
        return MATCH_NEXT;

    #undef NEXT_OP
    #undef PEEK_ARG
    }

  #+END_SRC

  На каждом полученном событии мы обходим список current_threads, выполняя сопоставляющие шаблон
  инструкции.

  Если встречается инструкция NEXT, то поток помещается в список next_threads, то есть ждет
  получения следующего события.

  Если шаблон в одном из потоков не совпадает с полученным событием, то такой поток просто не
  добавляется в список next_threads.

  Инструкция MATCH немедленно выходит из функции, сообщая кодом возврата о наличии шаблона в сессии.
  По завершению обхода списка потоков текущий и следующий списки меняются местами.

  Собственно, все. Можно сказать, что мы буквально делаем то, хотели: одновременно сверяем несколько
  шаблонов, запуская по одному новому процессу сопоставления на каждое из событий сессии.

* Множественные личности и ветвления в шаблонах

  Искать шаблон, описывающий линейную последовательность событий, конечно, полезно, но мы же хотим
  полноценные регулярные выражения. И потоки, которые мы сделали на предыдущем этапе, тут
  пригодятся.

  Предположим, мы хотим найти последовательность из двух или трех интересных нам событий, что-то
  вроде регулярного выражения на строках: "a?bc". В этой последовательности символ "а" опционален.
  Как это выразить в байт-коде? А легко!

  Мы можем запустить /два/ потока, по одному для каждого из случаев, с символом "a" и без него. Для
  этого введем дополнительную инструкцию (вида SPLIT addr1, addr2), которая запускает два потока с
  указанных адресов. Кроме SPLIT нам пригодится еще JUMP, которая просто продолжает исполнение с
  указанной в непосредственном аргументе инструкции:

  #+BEGIN_SRC cpp
    typedef enum matcher_opcode {
        OP_ABORT,
        OP_NAME,
        OP_SCREEN,
        OP_NEXT,
        OP_JUMP,                    // перейти к указанной инструкции
        OP_SPLIT,                   // запустить два новых потока с обеих указанных инструкций
        OP_MATCH,
        OP_NUMBER_OF_OPS,           // это просто число инструкций
    } matcher_opcode;
  #+END_SRC

  Сам цикл и остальные инструкции не меняются, мы просто внесем два новых обработчика:

  #+BEGIN_SRC cpp
    // ...
    case OP_JUMP:{
        /* Добавить новый поток, продолжающий выполнение с нового адреса */
        uint16_t offset = NEXT_ARG(current_thread);
        add_current_thread(m, create_thread(m, offset));
        break;
    }
    case OP_SPLIT:{
        /* внести пару новых потоков в текущий список */
        uint16_t left_offset = NEXT_ARG(current_thread);
        uint16_t right_offset = NEXT_ARG(current_thread);
        add_current_thread(m, create_thread(m, left_offset));
        add_current_thread(m, create_thread(m, right_offset));
        break;
    }
    // ...

  #+END_SRC

  Обратите внимание, что инструкции добавляют потоки в текущий список потоков, то есть потоки
  продолжают работу в контексте текущего события. Поток, в рамках которого произошло ветвление, на
  в список следующий потоков уже не попадает.

  Самое удивительное в этой виртуальной машине для регулярных выражений то, что наших потоков и этой пары
  инструкций достаточно для того, чтобы выразить почти все общепринятые в регулярных выражения на
  строках конструкции!

* Регулярные выражения на событиях

  Теперь, когда у нас есть походящая виртуальная машина и инструменты к ней, можно заняться,
  собственно, синтаксисом для наших регулярных выражений. Для начала ограничимся типом и контекстом
  события. Тип события обозначим единственным числом, если требуется указать контекст - указываем
  его через двоеточие:

  #+BEGIN_EXAMPLE
  13 # шаблон, состоящий из типа события 13
  #+END_EXAMPLE

  На языке ассемблера для нашей виртуальной машины это несложный шаблон выглядит следующим образом:

  #+BEGIN_EXAMPLE
  NEXT # следующее событие
  NAME 13 # проверка типа текущего события
  MATCH # есть совпадение
  #+END_EXAMPLE

  Теперь с контекстом:

  #+BEGIN_EXAMPLE
  13:12 # тип 13, контекст 12
  #+END_EXAMPLE

  Опкоды:

  #+BEGIN_EXAMPLE
  NEXT
  NAME 13
  SCREEN 12
  MATCH
  #+END_EXAMPLE

  Последовательные события должны быть как-то разделены, например, пробелами:

  #+BEGIN_EXAMPLE
  13 11 10:9
  #+END_EXAMPLE

  Что соответствует опкодам:

  #+BEGIN_EXAMPLE
  NEXT
  NAME 13
  NEXT
  NAME 11
  NEXT
  NAME 10
  SCREEN 9
  MATCH
  #+END_EXAMPLE

  Ручная запись опкодов для более серьезных программ быстро утомляет. К прошлой статье я не стал
  делать полноценный парсер, но пользователь @true-grue на примере мини-языка PigletC показал
  возможности своей библиотеки raddsl. Я был так впечатлен лаконичностью кода, что при помощи raddsl
  небольшой компилятор регулярных выражений строк в сто-двести на Python. Компилятор и инструкции по
  его применению есть на Гитхабе. Результат работы компилятора на языке ассемблера понимает утилита,
  читающая два файла (программу для виртуальной машины и список событий сессии для проверки).

  Итак, шаблон поинтересней:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "12|13"
  SPLIT L0 L1
  L0:
  NEXT
  NAME 12
  JUMP L2
  L1:
  NEXT
  NAME 13
  L2:
  MATCH
  #+END_EXAMPLE

  Обратите внимание на строки, закачивающиеся на двоеточие. Это метки. Инструкция SPLIT создает два
  потока, продолжающие выполнение с меток L0 и L1, а JUMP в конце первой из веток исполнения просто
  переходит к концу ветвления.

  Можно выбирать между цепочками выражений подлиннее, группируя подпоследовательности скобками:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "(1 2 3)|4"
  SPLIT L0 L1
  L0:
  NEXT
  NAME 1
  NEXT
  NAME 2
  NEXT
  NAME 3
  JUMP L2
  L1:
  NEXT
  NAME 4
  L2:
  MATCH
  #+END_EXAMPLE

  Произвольное событие обозначается точкой:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py ". 1"
  NEXT
  NEXT
  NAME 1
  MATCH
  #+END_EXAMPLE

  Если мы хотим сказать, что подпоследовательность опциональна, то ставим после нее знак вопроса:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1 2 3? 4"
  NEXT
  NAME 1
  NEXT
  NAME 2
  SPLIT L0 L1
  L0:
  NEXT
  NAME 3
  L1:
  NEXT
  NAME 4
  MATCH
  #+END_EXAMPLE

  Разумеется, поддерживаются и обычные в регулярных выражениях многократные повторения (плюс или
  звезда):

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1+ 2"
  L0:
  NEXT
  NAME 1
  SPLIT L0 L1
  L1:
  NEXT
  NAME 2
  MATCH
  #+END_EXAMPLE

  Здесь мы просто многократно выполняем инструкцию SPLIT, запуская на каждом цикле новые потоки.

  Аналогично со звездой:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1* 2"
  L0:
  SPLIT L1 L2
  L1:
  NEXT
  NAME 1
  JUMP L0
  L2:
  NEXT
  NAME 2
  MATCH
  #+END_EXAMPLE

* Заключение

  Кое-чего этой виртуальной машине все же не хватает. Например, можно легко ее расширить проверкой
  атрибутов событий. Для реальной системы я предполагаю использовать синтаксис вроде "1:2{3:4,
  5:>3}", что означает: событие 1 в контексте 2 с атрибутом 3, имеющим значение 4 и значением
  атрибута 5, превышающим 3.

  Другие полезные вещи, которые относительно легко добавить: уметь сохранять подпоследовательности
  регулярного выражения, разделить "жадные" и обычные операторы "звезду" и "плюс", и так далее. Наша
  виртуальная машина в терминах теории автоматов представляет собой недетерминированный конечный
  автомат, для реализаций которых такие вещи сделать несложно.

  На этой высокой ноте я закончиваю серию статей, посвященных реализациям виртуальных машин.
  Надеюсь, читателям Хабра серия понравилась и, разумеется, буду рад ответить на любые вопросы по
  теме.
