#+OPTIONS: ^:nil num:nil p:nil timestamp:nil todo:nil date:nil creator:nil author:nil toc:nil
#+TITLE: Иголка в стоге сессий, или Байт-код регулярных выражений
* Аннотация

  Семнадцать миллиардов событий, шестьдесят миллионов пользовательских сессий и невесть сколько
  виртуальных свиданий происходят в Badoo ежедневно. Каждое из событий аккуратно сохраняется в
  реляционные базы данных для последующего анализа на SQL и не только на нем.

  Современные распределенные транзакционные базы данных с десятками терабайт данных - настоящее чудо
  инженерной мысли. Но SQL как воплощение реляционной алгебры в стандартных реализациях не позволяет
  формулировать сложные запросы в терминах упорядоченных последовательностей кортежей.

  В последней из серии статей, посвященной виртуальным машинам, я расскажу про альтернативный подход
  к поиску интересных сессий: движок регулярных выражений ("Поросячий Матчер"), определенных для
  последовательностей событий.

  Виртуальная машина, байт-код и компилятор прилагаются бесплатно!

* О событиях и сессиях

  Предположим, у нас уже имеется хранилище данных, позволяющее быстро и последовательно
  просматривать события каждой из пользовательских сессий.

  Мы хотим находить сессии по запросами вида: "посчитать все сессии, где имеется указанная
  подпоследовательность событий", или "найти части сессии, описанные заданным шаблоном", или
  "вернуть ту часть сессии, которая случилась после заданного шаблона", или "посчитать, сколько
  сессий достигли определенных частей шаблона". Это может пригодиться для самых разнообразных
  практических анализов: поиск подозрительных сессий, вороночный анализ и т.д.

  Искомые подпоследовательности надо как-то описывать. В самой простой форме эта задача похожа на
  поиск подстроки в тексте; нам же хочется иметь инструмент помощнее - регулярные выражения.
  Современные реализации движков регулярных выражений чаще всего используют - вы угадали! -
  виртуальные машины.

  Созданием небольших виртуальных машинок для сопоставления сессий с регулярными выражениями мы и
  займемся в этой статье. Но давайте сначала уточним определения.

  /Событие/ состоит из типа события, времени, контекста и набора атрибутов, специфичных для
  каждого из типов.

  /Тип/ и /контекст/ каждого из событий это целые числа из предопределенных списков. Если с типами
  событий все понятно, то контекст это, например, номер экрана, на котором произошло заданное
  событие.

  /Атрибут/ события это произвольное целое число, смысл которого определяется типом события. Атрибутов
  у события может не быть, или быть несколько.

  /Сессия/ это последовательность событий, отсортированных по времени.

  Но давайте, наконец, перейдем к делу. Гул, как говорится, затих, а я вышел на подмостки.

* Сравниваем по бумажке

  Особенность данной виртуальной машины - пассивность по отношению ко входным событиям. Мы не хотим
  держать всю сессию в памяти и позволять виртуальной машине самостоятельно переходить от события к
  событию. Вместо этого мы будем одно за другим подавать события из сессии в виртуальную машинку.

  Определимся с интерфейсными функциями:

  #+BEGIN_SRC cpp

    matcher *matcher_create(uint8_t *bytecode);

    match_result matcher_accept(matcher *m, uint32_t event);

    void matcher_destroy(matcher *matcher);

  #+END_SRC

  Если с функциями matcher_create и matcher_destroy все понятно, то matcher_accept стоит
  прокомментировать. Функция matcher_accept получает на вход экземпляр виртуальной машины и
  очередное событие (32 бита, где 16 бит на тип события и 16 бит на контекст), а возращает код,
  поясняющий, что пользовательскому коду делать дальше:

  #+BEGIN_SRC cpp

    typedef enum match_result {
        MATCH_NEXT,                 // подать на вход еще одно событие
        MATCH_OK,                   // успешно найден искомый шаблон, события больше можно не подавать
        MATCH_FAIL,                 // текущая сессия не похожа на искомый шаблон, события можно больше
                                    // не подавать
        MATCH_ERROR,                // внутренняя ошибка в коде
    } match_result;

  #+END_SRC

  Опкоды виртуальной машины:

  #+BEGIN_SRC cpp

    typedef enum matcher_opcode {
        OP_ABORT,                   // нулевой опкод, сразу останавливает выполнение с ошибкой
        OP_NAME,                    // проверить тип текущего события тип (аргумент - искомый тип)
        OP_SCREEN,                  // проверить контекст текущего события (аргумент - искомый контекст)
        OP_NEXT,                    // запросить следующее событие
        OP_MATCH,                   // успешно завершить поиск
    } matcher_opcode;

  #+END_SRC

  Главный цикл виртуальной машины:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP()                               \
        (*m->ip++)
    #define NEXT_ARG()                              \
        ((void)(m->ip += 2), (m->ip[-2] << 8) + m->ip[-1])

        for (;;) {
            uint8_t instruction = NEXT_OP();
            switch (instruction) {
            case OP_ABORT:{
                return MATCH_ERROR;
            }
            case OP_NAME:{
                uint16_t name = NEXT_ARG();
                if (event_name(next_event) != name)
                    return MATCH_FAIL;
                break;
            }
            case OP_SCREEN:{
                uint16_t screen = NEXT_ARG();
                if (event_screen(next_event) != screen)
                    return MATCH_FAIL;
                break;
            }
            case OP_NEXT:{
                return MATCH_NEXT;
            }
            case OP_MATCH:{
                return MATCH_OK;
            }
            default:{
                return MATCH_ERROR;
            }
            }
        }

    #undef NEXT_OP
    #undef PEEK_ARG
    }
  #+END_SRC

  В этом простеньком варианте наша виртуальная машина последовательно сопоставляет шаблон, описанный
  байт-кодом, со входящими событиями. В таком виде это просто не слишком лаконичное сопоставление
  /префиксов/ двух строк: искомого шаблона и входной строки.

  Префиксы префиксами, но мы хотим находить искомые шаблоны не только в начале, но и в произвольном
  месте сессии. Наивное решение - перезапуск сопоставления с каждого события сессии. Но это
  подразумевает многократный просмотр каждого из событий и поедание алгоритмических младенцев.

  Пример из первой части серии статей, в сущности, имитирует перезапуск сопоставления при помощи
  отката (англ. backtracking). Код в примере выглядит, конечно, стройней приведенного здесь, но
  проблема никуда не делось: каждое из событий придется проверить многократно.

  Так жить нельзя.

* Я, еще раз я и снова я

  Давайте еще раз проговорим задачу: надо сопоставлять шаблон со входящими событиями, от каждого из
  событий начиная новое сопоставление. Так почему бы нам именно это и не делать? Пускай виртуальная
  машина будет идти по входящим событиям в несколько /потоков/!

  Для этого нам потребуется завести новую сущность - поток. Каждый поток хранит единственный
  указатель - на текущую инструкцию:

  #+BEGIN_SRC cpp

    typedef struct matcher_thread {
        uint8_t *ip;
    } matcher_thread;

  #+END_SRC

  Естественно, что и в самой виртуальной машине мы теперь явный указатель хранить не будем. Его
  заменяют два списка потоков (о них чуть ниже):

  #+BEGIN_SRC cpp

    typedef struct matcher {
        uint8_t *bytecode;

        /* Threads to be processed using the current event */
        matcher_thread current_threads[MAX_THREAD_NUM];
        uint8_t current_thread_num;

        /* Threads to be processed using the event to follow */
        matcher_thread next_threads[MAX_THREAD_NUM];
        uint8_t next_thread_num;

    } matcher;

  #+END_SRC

  А вот и обновленный главный цикл:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP(thread)                         \
        (*(thread).ip++)
    #define NEXT_ARG(thread)                                                \
        ((void)((thread).ip += 2), ((thread).ip[-2] << 8) + (thread).ip[-1])

        /* Каждое полученное событие запускает новый поток с начала байт-кода */
        add_current_thread(m, initial_thread(m));

        // На полученное событие мы обрабатываем каждый из потоков
        for (size_t thread_i = 0; thread_i < m->current_thread_num; thread_i++ ) {
            matcher_thread current_thread = m->current_threads[thread_i];

            bool thread_done = false;
            while (!thread_done) {
                uint8_t instruction = NEXT_OP(current_thread);
                switch (instruction) {
                case OP_ABORT:{
                    return MATCH_ERROR;
                }
                case OP_NAME:{
                    uint16_t name = NEXT_ARG(current_thread);
                    // если выясняется, что текущее событие не соответствует шаблону, то текущий поток
                    // не помещается в список next_threads, и завершает выполнение
                    if (event_name(next_event) != name)
                        thread_done = true;
                    break;
                }
                case OP_SCREEN:{
                    uint16_t screen = NEXT_ARG(current_thread);
                    if (event_screen(next_event) != screen)
                        thread_done = true;
                    break;
                }
                case OP_NEXT:{
                    // поток запросил следующее событие, т.е. должен быть помещен в список next_threads
                    add_next_thread(m, current_thread);
                    thread_done = true;
                    break;
                }
                case OP_MATCH:{
                    return MATCH_OK;
                }
                default:{
                    return MATCH_ERROR;
                }
                }
            }
        }

        /* Меняем местами текущий и следующий списки, запрашиваем следующее событие */
        swap_current_and_next(m);
        return MATCH_NEXT;

    #undef NEXT_OP
    #undef PEEK_ARG
    }

  #+END_SRC

  На каждом полученном событии мы обходим сначала вносим в список current_threads новый поток,
  проверяющий шаблон с самого начала; после чего начинаем обход списка current_threads, для каждого
  из потоков выполняя инструкции по указателю.

  Если встречается инструкция NEXT, то поток помещается в список next_threads, то есть ждет
  получения следующего события.

  Если шаблон в одном из потоков не совпадает с полученным событием, то такой поток просто не
  добавляется в список next_threads.

  Инструкция MATCH немедленно выходит из функции, сообщая кодом возврата о наличии шаблона в сессии.
  По завершению обхода списка потоков текущий и следующий списки меняются местами.

  Собственно, все. Можно сказать, что мы буквально делаем то, хотели: одновременно сверяем несколько
  шаблонов, запуская по одному новому процессу сопоставления на каждое из событий сессии.

* Множественные личности и ветвления в шаблонах

  Искать шаблон, описывающий линейную последовательность событий, конечно, полезно, но мы же хотим
  полноценные регулярные выражения. И потоки, которые мы сделали на предыдущем этапе, тут
  пригодятся.

  Предположим, мы хотим найти последовательность из двух или трех интересных нам событий, что-то
  вроде регулярного выражения на строках: "a?bc". В этой последовательности символ "а" опционален.
  Как это выразить в байт-коде? А легко!

  Мы можем запустить /два/ потока, по одному для каждого из случаев, с символом "a" и без него. Для
  этого введем дополнительную инструкцию (вида SPLIT addr1, addr2), которая запускает два потока с
  указанных адресов. Кроме SPLIT нам пригодится еще JUMP, которая просто продолжает исполнение с
  указанной в непосредственном аргументе инструкции:

  #+BEGIN_SRC cpp
    typedef enum matcher_opcode {
        OP_ABORT,
        OP_NAME,
        OP_SCREEN,
        OP_NEXT,
        OP_JUMP,                    // перейти к указанной инструкции
        OP_SPLIT,                   // запустить два новых потока с обеих указанных инструкций
        OP_MATCH,
        OP_NUMBER_OF_OPS,           // это просто число инструкций
    } matcher_opcode;
  #+END_SRC

  Сам цикл и остальные инструкции не меняются, мы просто внесем два новых обработчика:

  #+BEGIN_SRC cpp
    // ...
    case OP_JUMP:{
        /* Добавить новый поток, продолжающий выполнение с нового адреса */
        uint16_t offset = NEXT_ARG(current_thread);
        add_current_thread(m, create_thread(m, offset));
        break;
    }
    case OP_SPLIT:{
        /* внести пару новых потоков в текущий список */
        uint16_t left_offset = NEXT_ARG(current_thread);
        uint16_t right_offset = NEXT_ARG(current_thread);
        add_current_thread(m, create_thread(m, left_offset));
        add_current_thread(m, create_thread(m, right_offset));
        break;
    }
    // ...

  #+END_SRC

  Обратите внимание, что инструкции добавляют потоки в текущий список потоков, то есть потоки
  продолжают работу в контексте текущего события. Поток, в рамках которого произошло ветвление, на
  в список следующий потоков уже не попадает.

  Самое удивительное в этой виртуальной машине для регулярных выражений то, что наших потоков и этой пары
  инструкций достаточно для того, чтобы выразить почти все общепринятые в регулярных выражения на
  строках конструкции!

* Регулярные выражения на событиях

  Теперь, когда у нас есть походящая виртуальная машина и инструменты к ней, можно заняться,
  собственно, синтаксисом для наших регулярных выражений.

  Ручная запись опкодов для более серьезных программ быстро утомляет. К прошлой статье я не стал
  делать полноценный парсер, но пользователь @true-grue на примере мини-языка PigletC показал
  возможности своей библиотеки raddsl. Я был так впечатлен лаконичностью кода, что при помощи raddsl
  написал небольшой компилятор регулярных выражений строк в сто-двести на Python. Компилятор и
  инструкции по его применению есть на Гитхабе. Результат работы компилятора на языке ассемблера
  понимает утилита, читающая два файла (программу для виртуальной машины и список событий сессии для
  проверки).

  Для начала ограничимся типом и контекстом события. Тип события обозначим единственным числом, если
  требуется указать контекст - указываем его через двоеточие. Простейший пример:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "13" # шаблон, состоящий из типа события 13
  NEXT
  NAME 13
  MATCH
  #+END_EXAMPLE

  Теперь пример с контекстом:

  #+BEGIN_EXAMPLE
  python regexp/regexp.py "13:12" # тип 13, контекст 12
  NEXT
  NAME 13
  SCREEN 12
  MATCH
  #+END_EXAMPLE

  Последовательные события должны быть как-то разделены, например, пробелами:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "13 11 10:9"                                                                             08:40:52
  NEXT
  NAME 13
  NEXT
  NAME 11
  NEXT
  NAME 10
  SCREEN 9
  MATCH
  #+END_EXAMPLE

  Шаблон поинтересней:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "12|13"
  SPLIT L0 L1
  L0:
  NEXT
  NAME 12
  JUMP L2
  L1:
  NEXT
  NAME 13
  L2:
  MATCH
  #+END_EXAMPLE

  Обратите внимание на строки, закачивающиеся на двоеточие. Это метки. Инструкция SPLIT создает два
  потока, продолжающие выполнение с меток L0 и L1, а JUMP в конце первой из веток исполнения просто
  переходит к концу ветвления.

  Можно выбирать между цепочками выражений подлиннее, группируя подпоследовательности скобками:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "(1 2 3)|4"
  SPLIT L0 L1
  L0:
  NEXT
  NAME 1
  NEXT
  NAME 2
  NEXT
  NAME 3
  JUMP L2
  L1:
  NEXT
  NAME 4
  L2:
  MATCH
  #+END_EXAMPLE

  Произвольное событие обозначается точкой:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py ". 1"
  NEXT
  NEXT
  NAME 1
  MATCH
  #+END_EXAMPLE

  Если мы хотим сказать, что подпоследовательность опциональна, то ставим после нее знак вопроса:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1 2 3? 4"
  NEXT
  NAME 1
  NEXT
  NAME 2
  SPLIT L0 L1
  L0:
  NEXT
  NAME 3
  L1:
  NEXT
  NAME 4
  MATCH
  #+END_EXAMPLE

  Разумеется, поддерживаются и обычные в регулярных выражениях многократные повторения (плюс или
  звезда):

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1+ 2"
  L0:
  NEXT
  NAME 1
  SPLIT L0 L1
  L1:
  NEXT
  NAME 2
  MATCH
  #+END_EXAMPLE

  Здесь мы просто многократно выполняем инструкцию SPLIT, запуская на каждом цикле новые потоки.

  Аналогично со звездой:

  #+BEGIN_EXAMPLE
  > python regexp/regexp.py "1* 2"
  L0:
  SPLIT L1 L2
  L1:
  NEXT
  NAME 1
  JUMP L0
  L2:
  NEXT
  NAME 2
  MATCH
  #+END_EXAMPLE

* Перспектива

  Могут пригодится и другие расширения описанной виртуальной машины.

  Например, можно легко ее расширить проверкой атрибутов событий. Для реальной системы я предполагаю
  использовать синтаксис вроде "1:2{3:4, 5:>3}", что означает: событие 1 в контексте 2 с атрибутом
  3, имеющим значение 4 и значением атрибута 5, превышающим 3. Атрибуты здесь можно просто
  передавать массивом в функцию matcher_accept.

  Если передавать в matcher_accept еще и временной интервал между событиями, то в язык шаблонов
  можно добавить синтаксис, позволяющий пропускать время между событиями: "1 mindelta(120) 2", что
  будет означает "событие 1, потом промежуток минимум в 120 секунд, событие 2". В сочетании с
  сохранением подпоследовательности это позволяет собирать поведение пользователей между двумя
  подпоследовательностями событий.

  Другие полезные вещи, которые относительно легко добавить: уметь сохранять подпоследовательности
  регулярного выражения, разделить "жадные" и обычные операторы "звезду" и "плюс", и так далее. Наша
  виртуальная машина в терминах теории автоматов представляет собой недетерминированный конечный
  автомат, для реализаций которых такие вещи сделать несложно.

* Заключение

  Наша система разрабатывается под живые пользовательские интерфейсы, поэтому и движок хранения
  сессий самописный и оптимизирован именно под быстрый проход по всем сессиям. Все миллиарды
  событий, разбитые на сессии, проверяются на соответствие шаблонам за единицы секунд.

  Если скорость не так критична, то похожую систему можно оформить в виде расширения для
  какой-нибудь чуть более стандартной системы хранения данных, вроде традиционных реляционных баз
  данных или распределенной файловой системы.

  Отвлекаясь от событий и регулярных выражений хочу повторить, что применимость виртуальные машины
  гораздо шире, чем может показаться на первый взгляд. Эта техника подходит и широко применяется во
  всех случаях, где есть необходимость твердо разделить примитивы, которые понимает движок системы,
  и "парадную" подсистему, то есть какой-то DSL или язык программирования.

  На этой высокой ноте я закончиваю серию статей, посвященных различным применениям интерпретаторов
  байт-кода и виртуальным машинам. Надеюсь, читателям Хабра серия понравилась и, разумеется, буду
  рад ответить на любые вопросы по теме.

* Неформальный список литературы

  Практические аспекты разработки движков регулярных выражений обсуждаются в популярной литературе
  по компиляторам редко. "Поросячий Матчер" и пример из первой части статьи основывается на идеях из
  потрясающей серии статей Расса Кокса, одного из разработчиков движка Google Re2.

  Теория формальных языков и регулярных выражений излагается во всех академических учебниках,
  посвященных компиляторам. Здесь принято ссылаться на знаменитую "Книгу дракона", но я бы
  рекомендовал начать с приведенных выше ссылок.

  В статье я впервые для себя использовал интересную систему для быстрой разработки компиляторов на
  Питоне - raddsl, принадлежащую перу пользователя @true-grue (спасибо, Петр!). Если у вас стоит
  задача протипирования языка, или быстрой разработки какого-то DSL, то стоит обратить на нее
  внимание.
