#+OPTIONS: ^:nil num:nil p:nil timestamp:nil todo:nil date:nil creator:nil author:nil toc:nil
#+TITLE: Иголка в стоге сессий, или Байт-код регулярных выражений
* DONE Аннотация

  Семнадцать миллиардов событий, шестьдесят миллионов пользовательских сессий и невесть сколько
  виртуальных свиданий происходят в Badoo ежедневно. Каждое из событий аккуратно сохраняется в
  реляционные базы данных для последующего анализа на SQL и не только на нем.

  Современные распределенные транзакционные базы данных с десятками терабайт данных - настоящее чудо
  инженерной мысли. Но SQL как воплощение реляционной алгебры в стандартных реализациях не позволяет
  формулировать сложные запросы в терминах упорядоченных последовательностей кортежей.

  В последней из моих статей, посвященных виртуальным машинам, я расскажу про альтернативный подход:
  движок регулярных выражений ("Поросячий Матчер"), определенных для последовательностей событий -
  пользовательских сессий.

* DONE О событиях и сессиях

  Мы хотим находить сессии по запросами вида: "посчитать все сессии, где имеется указанная
  подпоследовательность событий", или "найти части сессии, описанные заданным шаблоном", или
  "вернуть ту часть сессии, которая случилась после заданного шаблона", или "посчитать, сколько
  сессий достигли определенных частей шаблона". Это может пригодиться для самых разнообразных
  практических анализов: поиск подозрительных сессий, вороночный анализ и т.д.

  Искомые подпоследовательности надо как-то описывать. В самой простой форме эта задача похожа на
  обычный поиск подстроки в тексте; нам же хочется иметь инструмент помощнее - регулярные выражения.
  А современные реализации движков регулярных выражений чаще всего используют - вы угадали! -
  виртуальные машины.

  Созданием небольших виртуальных машинок для сопоставления сессий с регулярными выражениями мы и
  займемся. Но давайте сначала уточним определения.

  Итак, /событие/ состоит из типа события, времени, контекста и набора атрибутов, специфичных для
  каждого из типов.

  /Тип/ и /контекст/ каждого из событий это целые числа из предопределенных списков. Если с типами
  событий все понятно, то контекст это, например, номер экрана, на котором произошло заданное
  событие.

  /Атрибут/ события это произвольное целое число, смысл которого определяется типом события. Атрибутов
  у события может не быть, или быть несколько.

  /Сессия/ это последовательность событий, отсортированных по времени.

  Но давайте, наконец, перейдем к делу. "Гул затих. я вышел на подмостки. "

* DONE Сравниваем по бумажке

  Особенность данной виртуальной машины - пассивность по отношению ко входным данным. Мы не хотим
  держать всю сессию в памяти и позволять виртуальной машине переходить от события к событию. Вместо
  этого мы будем одно за другим подавать события из сессии в виртуальную машинку. Определимся с
  интерфейсными функциями:

  #+BEGIN_SRC cpp

    matcher *matcher_create(uint8_t *bytecode);

    match_result matcher_accept(matcher *m, uint32_t event);

    void matcher_destroy(matcher *matcher);

  #+END_SRC

  Если с функциями matcher_create и matcher_destroy все понятно, то matcher_accept придется
  прокомментировать. Функция matcher_accept получает на вход экземпляр виртуальной машины и
  очередное событие (32 бита, где 16 бит на тип события и 16 бит на контекст), а возращает код,
  поясняющий, что пользовательскому коду делать дальше:

  #+BEGIN_SRC cpp

    typedef enum match_result {
        MATCH_NEXT,                 // подать на вход еще одно событие
        MATCH_OK,                   // успешно найден искомый шаблон, события больше можно не подавать
        MATCH_FAIL,                 // текущая сессия не похожа на искомый шаблон, события можно больше
                                    // не подавать
        MATCH_ERROR,                // внутренняя ошибка в коде
    } match_result;

  #+END_SRC

  Опкоды, из которых состоит байт-код виртуальной машины:

  #+BEGIN_SRC cpp

    typedef enum matcher_opcode {
        OP_ABORT,                   // нулевой опкод, сразу останавливает выполнение с ошибкой
        OP_NAME,                    // проверить тип текущего события тип (аргумент - искомый тип)
        OP_SCREEN,                  // проверить контекст текущего события (аргумент - искомый контекст)
        OP_NEXT,                    // запросить следующее событие
        OP_MATCH,                   // успешно завершить поиск
    } matcher_opcode;

  #+END_SRC

  Главный цикл виртуальной машины:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP()                               \
        (*m->ip++)
    #define NEXT_ARG()                              \
        ((void)(m->ip += 2), (m->ip[-2] << 8) + m->ip[-1])

        for (;;) {
            uint8_t instruction = NEXT_OP();
            switch (instruction) {
            case OP_ABORT:{
                return MATCH_ERROR;
            }
            case OP_NAME:{
                uint16_t name = NEXT_ARG();
                if (event_name(next_event) != name)
                    return MATCH_FAIL;
                break;
            }
            case OP_SCREEN:{
                uint16_t screen = NEXT_ARG();
                if (event_screen(next_event) != screen)
                    return MATCH_FAIL;
                break;
            }
            case OP_NEXT:{
                return MATCH_NEXT;
            }
            case OP_MATCH:{
                return MATCH_OK;
            }
            default:{
                return MATCH_ERROR;
            }
            }
        }

    #undef NEXT_OP
    #undef PEEK_ARG
    }
  #+END_SRC

  В этом простеньком варианте наша виртуальная машина последовательно сопоставляет шаблон из
  байт-кода со входящими событиями. В сущности это не слишком лаконично написанное сопоставление
  /префиксов/ двух строк: искомого шаблона и входной строки.

  Префиксы префиксами, но мы хотим находить искомые шаблоны не только в начале сессии, а в
  произвольном месте. Возможное наивное решение - перезапуск сопоставления с каждого события сессии.
  Но это подразумевает многократный просмотр каждого из событий и поедание алгоритмических
  младенцев.

  Пример из первой части серии статей, в сущности, имитирует перезапуск сопоставления при помощи
  отката (англ. backtracking). Код в примере выглядит, конечно, чище приведенного здесь, но суть
  проблемы не меняется: каждое из событий мы должны посмотреть многократно.

  Так жить решительно нельзя.

* DONE Я, еще раз я и снова я

  Давайте еще раз проговорим задачу: надо сопоставлять шаблон со входящими событиями, от каждого из
  событий начиная новое сопоставление. Так почему бы нам именно это и не делать? Пускай виртуальная
  машина будет идти по входящим событиям в несколько /потоков/!

  Для этого нам потребуется завести новую сущность - поток. Каждый поток хранит единственный
  указатель на текущую инструкцию:

  #+BEGIN_SRC cpp

    typedef struct matcher_thread {
        uint8_t *ip;
    } matcher_thread;

  #+END_SRC

  Естественно, что и в самой виртуальной машине мы теперь явный указатель хранить не будем. Его
  заменяют два списка потоков (о них чуть ниже):

  #+BEGIN_SRC cpp

    typedef struct matcher {
        uint8_t *bytecode;

        /* Threads to be processed using the current event */
        matcher_thread current_threads[MAX_THREAD_NUM];
        uint8_t current_thread_num;

        /* Threads to be processed using the event to follow */
        matcher_thread next_threads[MAX_THREAD_NUM];
        uint8_t next_thread_num;

    } matcher;

  #+END_SRC

  А вот и обновленный главный цикл:

  #+BEGIN_SRC cpp
    match_result matcher_accept(matcher *m, uint32_t next_event)
    {
    #define NEXT_OP(thread)                         \
        (*(thread).ip++)
    #define NEXT_ARG(thread)                                                \
        ((void)((thread).ip += 2), ((thread).ip[-2] << 8) + (thread).ip[-1])

        /* Каждое полученное событие запускает новый поток с начала байт-кода */
        add_current_thread(m, initial_thread(m));

        // На полученное событие мы обрабатываем каждый из потоков
        for (size_t thread_i = 0; thread_i < m->current_thread_num; thread_i++ ) {
            matcher_thread current_thread = m->current_threads[thread_i];

            bool thread_done = false;
            while (!thread_done) {
                uint8_t instruction = NEXT_OP(current_thread);
                switch (instruction) {
                case OP_ABORT:{
                    return MATCH_ERROR;
                }
                case OP_NAME:{
                    uint16_t name = NEXT_ARG(current_thread);
                    // если выясняется, что текущее событие не соответствует шаблону, то текущий поток
                    // не помещается в список next_threads, и завершает выполнение
                    if (event_name(next_event) != name)
                        thread_done = true;
                    break;
                }
                case OP_SCREEN:{
                    uint16_t screen = NEXT_ARG(current_thread);
                    if (event_screen(next_event) != screen)
                        thread_done = true;
                    break;
                }
                case OP_NEXT:{
                    // поток запросил следующее событие, т.е. должен быть помещен в список next_threads
                    add_next_thread(m, current_thread);
                    thread_done = true;
                    break;
                }
                case OP_MATCH:{
                    return MATCH_OK;
                }
                default:{
                    return MATCH_ERROR;
                }
                }
            }
        }

        /* Меняем местами текущий и следующий списки, запрашиваем следующее событие */
        swap_current_and_next(m);
        return MATCH_NEXT;

    #undef NEXT_OP
    #undef PEEK_ARG
    }

  #+END_SRC

  На каждом полученном событии мы обходим список current_threads, выполняя сопоставляющие шаблон
  инструкции. Если встречается инструкция NEXT, то поток помещается в список next_threads, то есть
  ждет получения следующей инструкции. Если шаблон в одном из потоков не совпадает с полученным
  событием, то такой поток просто не добавляется в список следующих инструкций. Инструкция MATCH
  просто немедленно рапортует о наличии шаблона в сопоставляемой сессии. По завершению обхода списка
  текущих потоков текущий и следующий списки меняются местами.

  Это, собственно, все. Можно сказать, что мы буквально делаем то, хотели: параллельно сверяем
  несколько шаблонов с каждым из входящих событий.

* TODO Множественные личности и ветвления в шаблонах
* TODO Регулярные выражения на событиях
* TODO Заключение
